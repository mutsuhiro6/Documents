---
lang: ja-jp
title: ソーティング
tags: Algorithm, Sort, Quick sort
---

# ソーティング

* 内部整列（internal sorting）
    * 全てを主記憶上で実行する
* 外部整列(external--)
    * 外部の補助記憶を用いる

## 種類

* [バブルソート(bubble--)](#バブルソート)
* [挿入ソート(insertion--)](#挿入ソート)
* [選択ソート(selection--)](#選択ソート)
* [ヒープソート(heap--)](#ヒープソート)
* [マージソート(merge--)](#マージソート)
* [クイックソート(quick--)](#クイックソート)

## バブルソート

隣り合う二つを比べて小さい方を左に

```clike
for(i = 0; i < N; i++){
    for(j = N; j > i; j--){
        if(arr[j] < arr[j-1])
            arr[j]とarr[j-1]を交換
    }
}
```
Complexity : $O(n^2)$

## 挿入ソート

`arr[i]`を`j<=i`番目の位置で`j<=k<i`に対して`arr[i]<arr[k]`でありかつ`arr[i]>=arr[j-1]`または`j==1`である位置に移す。

```clike
for(i = 1; i < N; i++){
    j = i;
    while(arr[j] > arr[k-1]){
        arr[j]とarr[j-1]を交換
        j = j-1;
    }
}
```

Complexity : $O(n^2)$

## 選択ソート

`arr[i]`から`arr[N-1]`のうちの最小値を選んで、それを`arr[i]`と入れ替えるのを`i=0`から`i=N-1`まで繰り返す。

```clike
for(i = 0; i < N; i++){
    arr[i]とmin(arr[0],...,arr[N-1])を交換
}
```
### 計算量
`min`を求めるのに、$O(n-i)$かかり、それをforループする。
Complexity : $O(n^2)$

## ヒープソート

```clike
for(i = 0; i < N; i++)
    insert(A[i], H[i]);

for(i = 0; i < N; i++)
    A[i] = deletemin(H);
```
`insert()`、`deletemin()`が$O(\log{n})$ゆえ、Complexityは$O(n\log{n})$

## マージソート

1.　配列を、分割可能な限り分割する。
2.　分割された配列をソートしながらマージする。
3.　ソートの際、配列の先頭要素どうしを比較し、小さい方から順に追加していく。

### 計算量

* 配列を分割するのに$c'n$ステップ。
* ２分割された配列を再帰的にソート。$T(n/2)\times 2$ステップ。
* マージに$cn$ステップ。

以上から$T(n)=2T(n/2)+(c+c')n=O(n\log{n})$


## クイックソート

1. 整列する範囲の中から基準値(pivot)を１つ決める。
2. 基準値より小さいデータは左へ、大きいデータは右へ集める。
3. 左部分と、右部分のそれぞれにクイックソートを適用していく。

クイックソートや、マージソートは、分割倒置法(divide and conquer)と呼ばれる。


### pivotの選び方
配列をほぼ二等分し、選択に時間がかからないことが良い。
選び方は様々で、ランダム、左端右端中央の位置の中央値、左から見て最初に得られる２つの異なる値の大きい方...などなど

### 計算時間

一般の場合は、$O(n^2)$となるが、実際、数列をほぼ半分に分割するので、$O(n\log{n})$で、平均も同じ。

## 計算時間まとめ



|           |     best    |   average   |     worst   |
|---------- | ----------- | ----------- | ----------- |
|bubble--   |    $O(n)$   |   $O(n^2)$  |   $O(n^2)$  |
|insertion--|    $O(n)$   |   $O(n^2)$  |   $O(n^2)$  |
|selection--|   $O(n^2)$  |   $O(n^2)$  |   $O(n^2)$  |
|heap--     |$O(n\log{n})$|$O(n\log{n})$|$O(n\log{n})$|
|merge--    |$O(n\log{n})$|$O(n\log{n})$|$O(n\log{n})$|
|quick--    |$O(n\log{n})$|$O(n\log{n})$|   $O(n^2)$  |



